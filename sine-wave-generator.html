<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Animated Sine Wave Generator</title>
  <!-- Bootstrap 5 CSS -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
  <!-- Plotly JS -->
  <script src="https://cdn.plot.ly/plotly-2.27.0.min.js"></script>
  <!-- Google Font -->
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600&display=swap" rel="stylesheet">
  <!-- Font Awesome -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
  <style>
    :root {
      --primary-color: #00e5ff;
      --secondary-color: #00b8d4;
      --accent-color: #00ffea;
      --dark-color: #121212;
      --darker-color: #0a0a0a;
      --medium-dark-color: #202020;
      --light-dark-color: #303030;
      --text-color: #e0e0e0;
      --muted-text-color: #9e9e9e;
      --success-color: #00e676;
      --warning-color: #ffea00;
      --danger-color: #ff1744;
      --neon-blue: #00e5ff;
      --neon-pink: #ff00ff;
      --neon-green: #39ff14;
      --neon-yellow: #ffff00;
      --neon-purple: #bf00ff;
      --neon-orange: #ff9100;
      --border-radius: 12px;
      --box-shadow: 0 8px 30px rgba(0, 0, 0, 0.5);
      --transition: all 0.3s ease;
      
      /* New muted button colors */
      --muted-primary: rgba(0, 229, 255, 0.7);
      --muted-success: rgba(0, 230, 118, 0.7);
      --muted-warning: rgba(255, 234, 0, 0.7);
      --muted-danger: rgba(255, 23, 68, 0.7);
      --muted-secondary: rgba(48, 48, 48, 0.9);
    }
    
    body {
      background: var(--dark-color);
      font-family: 'Inter', sans-serif;
      color: var(--text-color);
      min-height: 100vh;
      padding: 20px 0;
    }
    
    .container {
      max-width: 95vw;
      padding: 0 20px;
    }
    
    h1 {
      font-weight: 600;
      margin-bottom: 0.5rem;
      color: var(--text-color);
      text-align: left;
    }
    
    h2 {
      font-weight: 500;
      font-size: 1.8rem;
      margin-bottom: 1rem;
      position: relative;
      display: inline-block;
      color: var(--text-color);
      text-shadow: 0 0 15px rgba(0, 229, 255, 0.4);
      padding-bottom: 10px;
      letter-spacing: 0.5px;
    }
    
    h2:after {
      content: '';
      position: absolute;
      left: 0;
      bottom: 0;
      width: 100%;
      height: 3px;
      background: linear-gradient(90deg, var(--muted-primary), transparent);
      border-radius: 3px;
    }
    
    .card {
      border: none;
      border-radius: var(--border-radius);
      box-shadow: var(--box-shadow);
      margin-bottom: 0;
      background: var(--medium-dark-color);
      overflow: hidden;
      transition: var(--transition);
      width: 100%;
    }
    
    .card:hover {
      transform: translateY(-5px);
      box-shadow: 0 12px 30px rgba(0, 0, 0, 0.7);
    }
    
    .card-header {
      background: linear-gradient(90deg, var(--light-dark-color), var(--medium-dark-color));
      color: var(--text-color);
      font-weight: 500;
      border: none;
      padding: 12px 20px;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    
    .card-title {
      margin: 0;
      font-weight: 500;
      font-size: 1.1rem;
    }
    
    .card-body {
      padding: 15px;
    }
    
    .btn {
      border-radius: 8px;
      font-weight: 500;
      padding: 8px 16px;
      transition: var(--transition);
    }
    
    .btn-primary {
      background: var(--muted-primary);
      border-color: var(--primary-color);
      color: var(--dark-color);
    }
    
    .btn-primary:hover {
      background: var(--primary-color);
      border-color: var(--primary-color);
      transform: translateY(-2px);
      color: var(--dark-color);
    }
    
    .btn-success {
      background: var(--muted-success);
      border-color: var(--success-color);
      color: var(--dark-color);
    }
    
    .btn-success:hover {
      background: var(--success-color);
      border-color: var(--success-color);
      transform: translateY(-2px);
      color: var(--dark-color);
    }
    
    .btn-warning {
      background: var(--muted-warning);
      border-color: var(--warning-color);
      color: var(--dark-color);
    }
    
    .btn-warning:hover {
      background: var(--warning-color);
      border-color: var(--warning-color);
      color: var(--dark-color);
      transform: translateY(-2px);
    }
    
    .btn-danger {
      background: var(--muted-danger);
      border-color: var(--danger-color);
    }
    
    .btn-danger:hover {
      background: var(--danger-color);
      border-color: var(--danger-color);
      transform: translateY(-2px);
    }
    
    .btn-secondary {
      background: var(--muted-secondary);
      border-color: var(--light-dark-color);
      color: var(--text-color);
    }
    
    .btn-secondary:hover {
      background: var(--light-dark-color);
      border-color: var(--light-dark-color);
      color: var(--text-color);
      transform: translateY(-2px);
    }
    
    .btn-sm {
      padding: 5px 10px;
      font-size: 0.85rem;
    }
    
    label {
      font-size: 0.75rem;
      font-weight: 500;
      margin-bottom: 3px;
      color: var(--muted-text-color);
    }
    
    .form-control {
      border-radius: 8px;
      border: 1px solid #444;
      font-size: 0.9rem;
      padding: 7px 12px;
      height: auto;
      box-shadow: none;
      background-color: var(--light-dark-color);
      color: var(--text-color);
    }
    
    .form-control:focus {
      border-color: var(--accent-color);
      box-shadow: 0 0 0 2px rgba(0, 229, 255, 0.25);
      background-color: var(--light-dark-color);
      color: var(--text-color);
    }
    
    .controls-row {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      align-items: center;
      margin-bottom: 8px;
    }
    
    .control-group {
      flex: 1;
      min-width: 100px;
      max-width: 140px;
    }
    
    #plot {
      border: none;
      border-radius: var(--border-radius);
      box-shadow: var(--box-shadow);
      background: var(--darker-color);
      margin-top: 20px;
      overflow: hidden;
      height: 600px;
      width: 100%;
    }
    
    .actions-bar {
      display: flex;
      gap: 8px;
      margin-bottom: 20px;
      justify-content: flex-end;
    }
    
    .actions-bar .btn {
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 6px 12px;
      font-size: 0.9rem;
    }
    
    .header-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 10px;
    }
    
    .signal-info {
      color: var(--muted-text-color);
      font-size: 0.85rem;
      display: flex;
      align-items: center;
      gap: 5px;
      margin: 0;
    }
    
    .component-badge {
      display: inline-block;
      padding: 2px 8px;
      border-radius: 12px;
      font-size: 0.7rem;
      font-weight: 500;
      background: rgba(0, 229, 255, 0.15);
      color: var(--neon-blue);
      margin-right: 5px;
    }
    
    .glow-text {
      text-shadow: 0 0 10px rgba(0, 229, 255, 0.7);
    }
    
    .dark-tooltip {
      background-color: var(--medium-dark-color) !important;
      color: var(--text-color) !important;
      border: 1px solid var(--light-dark-color) !important;
    }
    
    #signalsContainer {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
      gap: 20px;
      margin-bottom: 20px;
    }

    /* Settings Modal Styles */
    .modal-content {
      background: var(--medium-dark-color);
      border: 1px solid var(--light-dark-color);
      color: var(--text-color);
    }

    .modal-header {
      border-bottom: 1px solid var(--light-dark-color);
    }

    .modal-footer {
      border-top: 1px solid var(--light-dark-color);
    }

    .form-label {
      color: var(--text-color);
      font-size: 0.9rem;
    }

    .form-control {
      background-color: var(--light-dark-color);
      border-color: var(--darker-color);
      color: var(--text-color);
    }

    .form-control:focus {
      background-color: var(--light-dark-color);
      border-color: var(--accent-color);
      color: var(--text-color);
    }

    .form-select {
      background-color: var(--light-dark-color);
      border-color: var(--darker-color);
      color: var(--text-color);
      border-radius: 8px;
      padding: 7px 12px;
      font-size: 0.9rem;
    }

    .form-select:focus {
      background-color: var(--light-dark-color);
      border-color: var(--accent-color);
      color: var(--text-color);
      box-shadow: 0 0 0 2px rgba(0, 229, 255, 0.25);
    }

    .form-select option {
      background-color: var(--medium-dark-color);
      color: var(--text-color);
    }

    .signal-name-input {
      background: transparent;
      border: none;
      color: var(--text-color);
      font-weight: 500;
      font-size: 1.1rem;
      padding: 0;
      width: auto;
      min-width: 100px;
    }

    .signal-name-input:focus {
      background: var(--light-dark-color);
      border: 1px solid var(--accent-color);
      border-radius: 4px;
      padding: 2px 6px;
      outline: none;
    }

    /* New styles for the compact layout */
    .controls-header {
      display: flex;
      margin-bottom: 5px;
      padding-left: 75px; /* Make space for component badge */
      gap: 8px;
    }
    
    .controls-header .control-label {
      flex: 1;
      min-width: 100px;
      max-width: 140px;
      font-size: 0.75rem;
      font-weight: 500;
      color: var(--muted-text-color);
    }
    
    .controls-row {
      display: flex;
      flex-wrap: nowrap;
      gap: 8px;
      align-items: center;
      margin-bottom: 4px; /* Reduced from 8px */
      padding: 3px 0; /* Added a bit of padding */
    }
    
    .control-group {
      flex: 1;
      min-width: 100px;
      max-width: 140px;
    }
    
    .control-group .form-control {
      padding: 5px 8px; /* Make inputs smaller */
      height: 30px; /* Fixed height */
    }
    
    .card {
      margin-bottom: 12px; /* Reduced from default */
    }
    
    .card-body {
      padding: 12px; /* Reduced padding */
    }
    
    .control-group label {
      display: none; /* Hide individual labels */
    }

    /* Color selector styles */
    .color-selector {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .color-selector select {
      min-width: 150px; /* Increased from 120px for better visibility */
    }

    .color-preview {
      width: 24px;
      height: 24px;
      border-radius: 4px;
      border: 1px solid #444;
      flex-shrink: 0;
    }

    .form-control-color {
      width: 24px !important;
      height: 24px !important;
      padding: 0 !important;
      border: 1px solid #444;
      border-radius: 4px;
    }

    /* Style for color dropdown options */
    .form-select option {
      display: flex;
      padding: 8px; /* Increased padding */
      white-space: nowrap;
    }
    
    /* Additional styling for custom dropdown options */
    .dropdown-item {
      display: flex;
      align-items: center;
      gap: 8px;
    }
    
    .color-swatch {
      display: inline-block;
      width: 16px;
      height: 16px;
      border-radius: 2px;
      margin-right: 6px;
      border: 1px solid #444;
      flex-shrink: 0;
    }

    /* Fix for color option display */
    .color-option-text {
      position: relative;
      padding-left: 24px; /* Space for the color swatch */
    }

    .color-option-swatch {
      position: absolute;
      left: 0;
      top: 2px;
      width: 16px;
      height: 16px;
      border-radius: 3px;
      border: 1px solid #444;
    }

    /* Floating Controls */
    .floating-controls {
      position: absolute;
      top: 10px;
      left: 10px;
      display: flex;
      gap: 8px;
      z-index: 100;
      padding: 6px 8px;
      border-radius: 8px;
      background-color: rgba(32, 32, 32, 0.7);
      backdrop-filter: blur(4px);
      border: 1px solid rgba(80, 80, 80, 0.5);
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
      transition: opacity 0.3s ease;
      opacity: 0.6;
    }
    
    .floating-controls:hover {
      opacity: 1;
    }
    
    .plot-container {
      position: relative;
      width: 100%;
      margin-top: 20px;
    }
    
    .control-btn {
      width: 32px;
      height: 32px;
      display: flex;
      align-items: center;
      justify-content: center;
      color: var(--text-color);
      background-color: var(--muted-secondary);
      border: 1px solid var(--light-dark-color);
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.2s ease;
    }
    
    .control-btn:hover {
      background-color: var(--light-dark-color);
      transform: translateY(-2px);
    }
    
    .control-btn.active {
      background-color: var(--muted-primary);
      color: var(--dark-color);
    }
    
    .speed-indicator {
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 0.8rem;
      color: var(--text-color);
      width: 32px;
      height: 32px;
    }
  </style>
</head>
<body>
  <div class="container py-4">
    <div class="d-flex justify-content-between align-items-center mb-4">
      <h2><i class="fas fa-wave-square me-2"></i>Animated Sine Wave Generator</h2>
      <div class="actions-bar">
        <button id="addSignalBtn" class="btn btn-primary">
          <i class="fas fa-plus"></i> Add Signal
        </button>
        <button id="saveConfigBtn" class="btn btn-success">
          <i class="fas fa-save"></i> Save Config
        </button>
        <button id="settingsBtn" class="btn btn-secondary" data-bs-toggle="modal" data-bs-target="#settingsModal">
          <i class="fas fa-cog"></i> Settings
        </button>
      </div>
    </div>
    
    <div id="signalsContainer"></div>
    
    <div class="plot-container">
      <div class="floating-controls">
        <button class="control-btn" id="pausePlayBtn" title="Pause/Play">
          <i class="fas fa-play" id="playIcon"></i>
          <i class="fas fa-pause" id="pauseIcon" style="display: none;"></i>
        </button>
        <button class="control-btn" id="speedDownBtn" title="Decrease Speed">
          <i class="fas fa-minus"></i>
        </button>
        <div class="speed-indicator" id="speedIndicator">1x</div>
        <button class="control-btn" id="speedUpBtn" title="Increase Speed">
          <i class="fas fa-plus"></i>
        </button>
      </div>
      <div id="plot" style="width: 100%; height: 500px;"></div>
    </div>

    <!-- Settings Modal -->
    <div class="modal fade" id="settingsModal" tabindex="-1" aria-labelledby="settingsModalLabel" aria-hidden="true">
      <div class="modal-dialog">
        <div class="modal-content">
          <div class="modal-header">
            <h5 class="modal-title" id="settingsModalLabel">Plot Settings</h5>
            <button type="button" class="btn-close btn-close-white" data-bs-dismiss="modal" aria-label="Close"></button>
          </div>
          <div class="modal-body">
            <div class="mb-3">
              <div class="d-flex justify-content-between align-items-center mb-2">
                <label for="yAxisMin" class="form-label">Y-Axis Range</label>
                <button type="button" class="btn btn-sm btn-outline-secondary" id="resetYAxis">Auto Scale</button>
              </div>
              <div class="d-flex gap-2">
                <div class="flex-grow-1">
                  <label for="yAxisMin" class="form-label">Minimum</label>
                  <input type="number" class="form-control" id="yAxisMin" value="-2" step="0.1">
                </div>
                <div class="flex-grow-1">
                  <label for="yAxisMax" class="form-label">Maximum</label>
                  <input type="number" class="form-control" id="yAxisMax" value="2" step="0.1">
                </div>
              </div>
            </div>
            <div class="mb-3">
              <label for="animationSpeed" class="form-label">Animation Speed (0 to pause)</label>
              <input type="number" class="form-control" id="animationSpeed" value="1" step="0.1" min="0">
            </div>
            <div class="mb-3">
              <label for="xAxisWidth" class="form-label">X-Axis Width</label>
              <input type="number" class="form-control" id="xAxisWidth" value="10" step="0.5" min="1" max="20">
              <small class="form-text text-muted">Controls how much of the signal is visible at once (default: 10)</small>
            </div>
            <div class="mb-3">
              <label for="rightMargin" class="form-label">Right Margin</label>
              <input type="number" class="form-control" id="rightMargin" value="0.025" step="0.05" min="0" max="0.5">
              <small class="form-text text-muted">Expressed as a fraction of the x-axis width (0.025 = 2.5%)</small>
            </div>
          </div>
          <div class="modal-footer">
            <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
            <button type="button" class="btn btn-primary" id="applySettings">Apply Settings</button>
          </div>
        </div>
      </div>
    </div>
  </div>

  <script>
    let signals = [];
    let signalCounter = 0;
    let animationOffset = 0;
    let noiseBuffers = []; // Store noise values for each signal component
    let yAxisMin = -2;
    let yAxisMax = 2;
    let animationSpeed = 1; // Default animation speed multiplier
    let isYAxisFixed = false; // Track if y-axis range is fixed by user
    let animationFrameId = null; // Track animation frame for pausing
    let historicalData = []; // Store historical data for each signal
    const maxPoints = 200; // Maximum number of points to display
    const scrollSpeed = 0.02; // Speed of x-axis scrolling
    let xAxisWidth = 10; // Width of the visible x-axis (made configurable)
    const pointSpacing = xAxisWidth / maxPoints; // Spacing between data points
    let rightPadding = xAxisWidth * 0.025; // Right padding (made configurable)

    // Initial signal configurations
    const initialConfig = {
      "signals": [
        {
          "components": [
            {
              "amp": 0.2,
              "freq": 16,
              "phase": 2.8,
              "noise_std": 0.1
            },
            {
              "amp": 1,
              "freq": 1,
              "phase": 0,
              "noise_std": 0.1
            },
            {
              "amp": 4,
              "freq": 0.4,
              "phase": 0,
              "noise_std": 0.1
            }
          ]
        },
        {
          "components": [
            {
              "amp": 0.3,
              "freq": 12,
              "phase": 1.5,
              "noise_std": 0.15
            },
            {
              "amp": 3,
              "freq": 0.3,
              "phase": 2,
              "noise_std": 1.25
            },
            {
              "amp": 5,
              "freq": 1,
              "phase": 0.5,
              "noise_std": 0.015
            }
          ]
        },
        {
          "components": [
            {
              "amp": 0.7,
              "freq": 3,
              "phase": 3.0,
              "noise_std": 0.2
            },
            {
              "amp": 3.5,
              "freq": 1.5,
              "phase": 2.2,
              "noise_std": 0.05
            },
          ]
        }
      ]
    };
    
    // Load initial configuration
    function loadInitialConfig() {
      // Initialize historical data array
      historicalData = [];
      
      initialConfig.signals.forEach((signalConfig, signalIndex) => {
        signalCounter++;
        const signalId = signalCounter;
        const colorName = getMutedColorName(signalIndex);
        const colorValue = colorPresets[colorName];
        const signal = { 
          id: signalId, 
          components: [], 
          name: `Signal ${signalId}`, 
          color: colorValue 
        };
        signals.push(signal);
        
        const signalHtml = `
        <div class="card" id="signal${signalId}_card">
          <div class="card-header">
            <input type="text" class="signal-name-input" id="signal${signalId}_name" value="Signal ${signalId}" onchange="updateSignalName(${signalId}, this.value)">
            <div class="d-flex gap-2">
              <select class="form-select form-select-sm" style="width: auto;" onchange="applyPattern(${signalId}, this.value)">
                <option value="">Custom</option>
                ${Object.keys(naturalPatterns).map(pattern => 
                  `<option value="${pattern}">${pattern}</option>`
                ).join('')}
              </select>
              <button class="btn btn-danger btn-sm" onclick="removeSignal(${signalId})">
                <i class="fas fa-trash"></i> Remove
              </button>
            </div>
          </div>
          <div class="card-body">
            <div class="header-row">
              <div class="signal-info">
                <i class="fas fa-wave-square"></i> Components:
              </div>
              <div class="d-flex gap-2 align-items-center">
                <div class="color-selector" style="display: flex; align-items: center; gap: 4px;">
                  <select class="form-select form-select-sm" id="signal${signalId}_colorSelect" 
                    style="width: auto;" onchange="handleColorSelection(${signalId}, this)">
                    ${Object.entries(colorPresets).map(([name, color]) => 
                      createColorOption(name, color)
                    ).join('')}
                    <option value="custom">Custom Color</option>
                  </select>
                  <div class="color-preview" style="width: 24px; height: 24px; border-radius: 4px; background-color: ${signal.color}; border: 1px solid #444;"></div>
                  <input type="color" class="form-control form-control-color" 
                    id="signal${signalId}_color" value="${signal.color}" 
                    onchange="handleCustomColorChange(${signalId}, this)" 
                    style="width: 24px; height: 24px; padding: 0; display: ${getColorName(signal.color) === 'Custom' ? 'block' : 'none'};">
                </div>
                <button class="btn btn-secondary btn-sm" onclick="addSineComponent(${signalId})">
                  <i class="fas fa-plus"></i> Add Component
                </button>
              </div>
            </div>
            <!-- Add controls header with labels -->
            <div class="controls-header">
              <div class="control-label">Amplitude</div>
              <div class="control-label">Frequency</div>
              <div class="control-label">Phase</div>
              <div class="control-label">Noise</div>
              <div style="width: 32px;"></div><!-- Space for delete button -->
            </div>
            <div id="signal${signalId}_components"></div>
          </div>
        </div>
        `;
        const signalsContainer = document.getElementById('signalsContainer');
        signalsContainer.insertAdjacentHTML('beforeend', signalHtml);
        
        // Add components with their initial values
        signalConfig.components.forEach(compConfig => {
          signal.componentCounter = (signal.componentCounter || 0) + 1;
          const compId = signal.componentCounter;
          const comp = { id: compId };
          signal.components.push(comp);

          const compHtml = `
          <div class="controls-row" id="signal${signalId}_comp${compId}_row">
            <span class="component-badge">Comp ${compId}</span>
            <div class="control-group">
              <input type="number" class="form-control" id="signal${signalId}_comp${compId}_amp" value="${compConfig.amp}" step="0.1" oninput="updatePlot()">
            </div>
            <div class="control-group">
              <input type="number" class="form-control" id="signal${signalId}_comp${compId}_freq" value="${compConfig.freq}" step="0.1" oninput="updatePlot()">
            </div>
            <div class="control-group">
              <input type="number" class="form-control" id="signal${signalId}_comp${compId}_phase" value="${compConfig.phase}" step="0.1" oninput="updatePlot()">
            </div>
            <div class="control-group">
              <input type="number" class="form-control" id="signal${signalId}_comp${compId}_noise" value="${compConfig.noise_std}" step="0.01" oninput="updatePlot()">
            </div>
            <button class="btn btn-danger btn-sm" onclick="removeSineComponent(${signalId}, ${compId})">
              <i class="fas fa-times"></i>
            </button>
          </div>
          `;
          const compContainer = document.getElementById(`signal${signalId}_components`);
          compContainer.insertAdjacentHTML('beforeend', compHtml);
        });
        
        // Set the correct color in the dropdown
        setTimeout(() => {
          const dropdown = document.getElementById(`signal${signalId}_colorSelect`);
          if (dropdown) {
            dropdown.value = colorName;
          }
        }, 0);
      });

      // Initialize historical data with initial values but only for the left side of the window
      const numPoints = maxPoints;
      
      // Set initial animation offset to 0
      animationOffset = 0;
      
      // Generate initial x values starting only from the left edge of the visible window
      // to the center (instead of going all the way to the right edge)
      const initialX = [];
      for (let i = 0; i < numPoints / 2; i++) {  // Only generate half the points
        initialX.push(-xAxisWidth + i * xAxisWidth / (numPoints / 2 - 1));
      }

      // Initialize historical data for each signal
      signals.forEach((signal, signalIndex) => {
        historicalData[signalIndex] = {
          x: [],
          y: []
        };

        // Generate initial y values for each point
        for (let i = 0; i < initialX.length; i++) {
          let y = 0;
          signal.components.forEach(component => {
            const ampInput = document.getElementById(`signal${signal.id}_comp${component.id}_amp`);
            const freqInput = document.getElementById(`signal${signal.id}_comp${component.id}_freq`);
            const phaseInput = document.getElementById(`signal${signal.id}_comp${component.id}_phase`);
            const noiseInput = document.getElementById(`signal${signal.id}_comp${component.id}_noise`);
            
            if (ampInput && freqInput && phaseInput && noiseInput) {
              const amp = parseFloat(ampInput.value) || 0;
              const freq = parseFloat(freqInput.value) || 0;
              const phase = parseFloat(phaseInput.value) || 0;
              const noiseStd = parseFloat(noiseInput.value) || 0;
              
              const sineValue = amp * Math.sin(freq * initialX[i] + phase);
              const noiseValue = noiseStd * randomNormal();
              y += sineValue + noiseValue;
            }
          });
          
          historicalData[signalIndex].x.push(initialX[i]);
          historicalData[signalIndex].y.push(y);
        }
      });

      updatePlot();
    }

    // Generate a normally distributed random number using the Box-Muller transform.
    function randomNormal() {
      let u = 0, v = 0;
      while(u === 0) u = Math.random();
      while(v === 0) v = Math.random();
      return Math.sqrt(-2.0 * Math.log(u)) * Math.cos(2.0 * Math.PI * v);
    }

    // Calculate the expected y-range based on all signal components
    function calculateYRange() {
      let maxAmplitude = 0;
      let maxNoise = 0;
      
      signals.forEach(signal => {
        signal.components.forEach(component => {
          const ampInput = document.getElementById(`signal${signal.id}_comp${component.id}_amp`);
          const noiseInput = document.getElementById(`signal${signal.id}_comp${component.id}_noise`);
          
          if (ampInput && noiseInput) {
            const amp = parseFloat(ampInput.value) || 0;
            const noise = parseFloat(noiseInput.value) || 0;
            
            // Account for possible constructive interference
            maxAmplitude += Math.abs(amp);
            maxNoise += noise * 2; // Reduced from 3 to 2 for tighter scaling
          }
        });
      });
      
      // Add minimal padding (1.02 instead of 1.05)
      const range = Math.max(2, maxAmplitude + maxNoise) * 1.02;
      return [-range, range];
    }

    // Update the plot using the current parameters and the animation offset.
    function updatePlot() {
      const traces = [];
      let yMin = Infinity;
      let yMax = -Infinity;
      
      signals.forEach((signal, signalIndex) => {
        // Initialize historical data for this signal if not exists
        if (!historicalData[signalIndex]) {
          historicalData[signalIndex] = {
            x: [],
            y: []
          };
        }
        
        // Calculate new point
        let newY = 0;
        signal.components.forEach((component, compIndex) => {
          const ampInput = document.getElementById(`signal${signal.id}_comp${component.id}_amp`);
          const freqInput = document.getElementById(`signal${signal.id}_comp${component.id}_freq`);
          const phaseInput = document.getElementById(`signal${signal.id}_comp${component.id}_phase`);
          const noiseInput = document.getElementById(`signal${signal.id}_comp${component.id}_noise`);
          
          if (ampInput && freqInput && phaseInput && noiseInput) {
            const amp = parseFloat(ampInput.value) || 0;
            const freq = parseFloat(freqInput.value) || 0;
            const phase = parseFloat(phaseInput.value) || 0;
            const noiseStd = parseFloat(noiseInput.value) || 0;
            
            // Calculate new point value using the current animation offset
            const sineValue = amp * Math.sin(freq * animationOffset + phase);
            const noiseValue = noiseStd * randomNormal();
            newY += sineValue + noiseValue;
          }
        });
        
        // Add new point to historical data
        historicalData[signalIndex].x.push(animationOffset);
        historicalData[signalIndex].y.push(newY);
        
        // Keep only the most relevant points for the current view
        // We want to keep points within the visible window plus some buffer
        const visibleStart = animationOffset - xAxisWidth;
        const visibleEnd = animationOffset + rightPadding;
        const bufferStart = visibleStart - xAxisWidth; // Keep an extra window worth of points
        
        // Remove points that are too old (far to the left of the current view with buffer)
        while (historicalData[signalIndex].x.length > 0 && 
               historicalData[signalIndex].x[0] < bufferStart) {
          historicalData[signalIndex].x.shift();
          historicalData[signalIndex].y.shift();
        }
        
        // Find min/max y values
        const componentMin = Math.min(...historicalData[signalIndex].y);
        const componentMax = Math.max(...historicalData[signalIndex].y);
        yMin = Math.min(yMin, componentMin);
        yMax = Math.max(yMax, componentMax);
        
        // Create filtered data for the visible range with some buffer
        const filteredData = {
          x: [],
          y: []
        };
        
        for (let i = 0; i < historicalData[signalIndex].x.length; i++) {
          if (historicalData[signalIndex].x[i] >= bufferStart) {
            filteredData.x.push(historicalData[signalIndex].x[i]);
            filteredData.y.push(historicalData[signalIndex].y[i]);
          }
        }
        
        traces.push({
          x: filteredData.x,
          y: filteredData.y,
          mode: 'lines',
          name: signals[signalIndex].name,
          line: {
            width: 3,
            color: signal.color || getNeonColor(signalIndex),
            shape: 'spline'
          }
        });
      });

      // Only update y-axis range if not fixed by user
      if (!isYAxisFixed) {
        const [calculatedMin, calculatedMax] = calculateYRange();
        yAxisMin = calculatedMin;
        yAxisMax = calculatedMax;
      }
      
      const layout = {
        title: {
          text: 'Generated Signals',
          font: {
            family: 'Inter, sans-serif',
            size: 20,
            color: '#e0e0e0'
          }
        },
        xaxis: { 
          title: {
            text: 'Time',
            font: {
              family: 'Inter, sans-serif',
              size: 14,
              color: '#9e9e9e'
            }
          },
          range: [animationOffset - xAxisWidth, animationOffset + rightPadding],  // Add padding to see new data appear
          gridcolor: '#333333',
          zerolinecolor: '#505050',
          color: '#9e9e9e'
        },
        yaxis: { 
          title: {
            text: 'Signal Value',
            font: {
              family: 'Inter, sans-serif',
              size: 14,
              color: '#9e9e9e'
            }
          },
          range: [yAxisMin, yAxisMax],
          gridcolor: '#333333',
          zerolinecolor: '#505050',
          color: '#9e9e9e'
        },
        margin: { t: 50, b: 50, l: 60, r: 40 },
        paper_bgcolor: '#121212',
        plot_bgcolor: '#121212',
        font: {
          family: 'Inter, sans-serif',
          color: '#e0e0e0'
        },
        legend: {
          x: 0,
          y: 1,
          bgcolor: 'rgba(32, 32, 32, 0.7)',
          bordercolor: 'rgba(80, 80, 80, 0.5)',
          borderwidth: 1,
          borderradius: 5,
          font: {
            color: '#e0e0e0'
          }
        }
      };
      
      Plotly.react('plot', traces, layout);
    }

    // Get a neon color for each signal based on index
    function getNeonColor(index) {
      const neonColors = [
        '#00e5ff',     // neon blue
        '#39ff14',     // neon green
        '#ff1744',     // neon red
        '#ffff00',     // neon yellow
        '#00ff7f',     // neon teal
        '#aaff00',     // neon lime
        '#008cff',     // neon sky blue
        '#bf00ff',     // neon purple
        '#ff9100',     // neon orange
        '#ff00ff'      // neon pink
      ];
      return neonColors[index % neonColors.length];
    }

    // Get a neon color name for each signal based on index (matching getNeonColor)
    function getNeonColorName(index) {
      const neonColorNames = [
        'Neon Blue',
        'Neon Green',
        'Neon Red',
        'Neon Yellow',
        'Neon Teal',
        'Neon Lime',
        'Neon Sky Blue',
        'Neon Purple',
        'Neon Orange',
        'Neon Pink'
      ];
      return neonColorNames[index % neonColorNames.length];
    }

    // Define color presets with names - muted colors first, then neon colors
    const colorPresets = {
      'Muted Blue': 'rgba(0, 229, 255, 0.5)',
      'Muted Green': 'rgba(57, 255, 20, 0.5)',
      'Muted Red': 'rgba(255, 23, 68, 0.5)',
      'Muted Yellow': 'rgba(255, 255, 0, 0.5)',
      'Muted Teal': 'rgba(0, 255, 127, 0.5)',
      'Muted Lime': 'rgba(170, 255, 0, 0.5)',
      'Muted Sky Blue': 'rgba(0, 140, 255, 0.5)',
      'Muted Purple': 'rgba(191, 0, 255, 0.5)',
      'Muted Orange': 'rgba(255, 145, 0, 0.5)',
      'Muted Pink': 'rgba(255, 0, 255, 0.5)',
      'Neon Blue': '#00e5ff',
      'Neon Green': '#39ff14',
      'Neon Red': '#ff1744',
      'Neon Yellow': '#ffff00',
      'Neon Teal': '#00ff7f',
      'Neon Lime': '#aaff00',
      'Neon Sky Blue': '#008cff',
      'Neon Purple': '#bf00ff',
      'Neon Orange': '#ff9100',
      'Neon Pink': '#ff00ff',
      'White': '#ffffff',
      'Gray': '#808080',
      'Black': '#000000'
    };

    // Function to get color name from hex
    function getColorName(hex) {
      for (const [name, color] of Object.entries(colorPresets)) {
        if (color.toLowerCase() === hex.toLowerCase()) {
          return name;
        }
      }
      return 'Custom';
    }

    // Function to create color option HTML
    function createColorOption(name, color) {
      return `<option value="${name}" data-color="${color}"><span class="color-option-text">${name}</span></option>`;
    }

    // Function to handle color selection change
    function handleColorSelection(signalId, selectElement) {
      const selectedValue = selectElement.value;
      const colorPreview = selectElement.parentElement.querySelector('.color-preview');
      const colorPicker = document.getElementById(`signal${signalId}_color`);
      
      if (selectedValue === 'custom') {
        // Show the color picker but keep the preview
        if (colorPicker) {
          colorPicker.style.display = 'block';
        }
      } else {
        // Use the preset color
        if (colorPicker) {
          colorPicker.style.display = 'none';
        }
        const selectedOption = selectElement.options[selectElement.selectedIndex];
        const color = selectedOption.dataset.color;
        updateSignalColor(signalId, color);
      }
    }

    // Function to handle custom color picker change
    function handleCustomColorChange(signalId, colorPicker) {
      const selectElement = document.getElementById(`signal${signalId}_colorSelect`);
      if (selectElement) {
        selectElement.value = 'custom';
      }
      updateSignalColor(signalId, colorPicker.value, true);
    }

    // Function to update signal color
    function updateSignalColor(signalId, newColor, isCustom = false) {
      const signal = signals.find(s => s.id === signalId);
      if (signal) {
        signal.color = newColor;
        // Update both the color picker and preview
        const colorPicker = document.getElementById(`signal${signalId}_color`);
        const colorPreview = colorPicker.parentElement.querySelector('.color-preview');
        if (colorPicker) {
          colorPicker.value = newColor;
        }
        if (colorPreview) {
          colorPreview.style.backgroundColor = newColor;
        }
        updatePlot();
      }
    }

    // Settings handling
    document.getElementById('applySettings').addEventListener('click', function() {
      const newYAxisMin = parseFloat(document.getElementById('yAxisMin').value);
      const newYAxisMax = parseFloat(document.getElementById('yAxisMax').value);
      const newAnimationSpeed = parseFloat(document.getElementById('animationSpeed').value);
      const newXAxisWidth = parseFloat(document.getElementById('xAxisWidth').value);
      const newRightMargin = parseFloat(document.getElementById('rightMargin').value);

      if (newYAxisMin >= newYAxisMax) {
        alert('Y-axis minimum must be less than maximum');
        return;
      }

      if (newAnimationSpeed < 0) {
        alert('Animation speed cannot be negative');
        return;
      }
      
      if (newXAxisWidth < 1) {
        alert('X-axis width must be greater than 0');
        return;
      }
      
      if (newRightMargin < 0 || newRightMargin > 0.5) {
        alert('Right margin must be between 0 and 0.5');
        return;
      }

      yAxisMin = newYAxisMin;
      yAxisMax = newYAxisMax;
      animationSpeed = newAnimationSpeed;
      xAxisWidth = newXAxisWidth;
      rightPadding = xAxisWidth * newRightMargin;
      isYAxisFixed = true;
      
      // Handle animation pausing
      if (newAnimationSpeed === 0) {
        if (animationFrameId) {
          cancelAnimationFrame(animationFrameId);
          animationFrameId = null;
        }
      } else if (!animationFrameId) {
        animate();
      }
      
      // Close the modal
      const modal = bootstrap.Modal.getInstance(document.getElementById('settingsModal'));
      modal.hide();
      
      // Update the plot with new settings
      updatePlot();
    });

    // Animation loop: increment animationOffset and update plot continuously.
    function animate() {
      if (animationSpeed > 0) {
        animationOffset += scrollSpeed * animationSpeed;
        updatePlot();
        animationFrameId = requestAnimationFrame(animate);
      }
    }

    // Adds a new sine component to a given signal.
    function addSineComponent(signalId) {
      const signal = signals.find(s => s.id === signalId);
      if (!signal) return;
      signal.componentCounter = (signal.componentCounter || 0) + 1;
      const compId = signal.componentCounter;
      const comp = { id: compId };
      signal.components.push(comp);

      const compHtml = `
      <div class="controls-row" id="signal${signalId}_comp${compId}_row">
        <span class="component-badge">Comp ${compId}</span>
        <div class="control-group">
          <input type="number" class="form-control" id="signal${signalId}_comp${compId}_amp" value="1" step="0.1" oninput="updatePlot()">
        </div>
        <div class="control-group">
          <input type="number" class="form-control" id="signal${signalId}_comp${compId}_freq" value="1" step="0.1" oninput="updatePlot()">
        </div>
        <div class="control-group">
          <input type="number" class="form-control" id="signal${signalId}_comp${compId}_phase" value="0" step="0.1" oninput="updatePlot()">
        </div>
        <div class="control-group">
          <input type="number" class="form-control" id="signal${signalId}_comp${compId}_noise" value="0.1" step="0.01" oninput="updatePlot()">
        </div>
        <button class="btn btn-danger btn-sm" onclick="removeSineComponent(${signalId}, ${compId})">
          <i class="fas fa-times"></i>
        </button>
      </div>
      `;
      const compContainer = document.getElementById(`signal${signalId}_components`);
      compContainer.insertAdjacentHTML('beforeend', compHtml);
      updatePlot();
    }

    // Removes a sine component from a signal.
    function removeSineComponent(signalId, compId) {
      const signal = signals.find(s => s.id === signalId);
      if (!signal) return;
      signal.components = signal.components.filter(c => c.id !== compId);
      const compRow = document.getElementById(`signal${signalId}_comp${compId}_row`);
      if (compRow) {
        compRow.remove();
      }
      updatePlot();
    }

    // Predefined natural wave patterns
    const naturalPatterns = {
      "Ocean Wave": {
        components: [
          { amp: 1.0, freq: 0.5, phase: 0, noise_std: 0.1 },    // Main wave
          { amp: 0.3, freq: 2.0, phase: 0, noise_std: 0.05 },   // Ripple
          { amp: 0.1, freq: 4.0, phase: 0, noise_std: 0.02 }    // Small ripples
        ]
      },
      "Heartbeat": {
        components: [
          { amp: 1.0, freq: 1.0, phase: 0, noise_std: 0.05 },   // Main beat
          { amp: 0.3, freq: 2.0, phase: 0, noise_std: 0.02 },   // Secondary beat
          { amp: 0.1, freq: 3.0, phase: 0, noise_std: 0.01 }    // Fine detail
        ]
      },
      "Earthquake": {
        components: [
          { amp: 2.0, freq: 0.2, phase: 0, noise_std: 0.5 },    // Main tremor
          { amp: 0.5, freq: 1.0, phase: 0, noise_std: 0.2 },    // Secondary waves
          { amp: 0.2, freq: 2.0, phase: 0, noise_std: 0.1 }     // Aftershocks
        ]
      },
      "Sound Wave": {
        components: [
          { amp: 1.0, freq: 8.0, phase: 0, noise_std: 0.05 },   // Main frequency
          { amp: 0.5, freq: 16.0, phase: 0, noise_std: 0.02 },  // Harmonic
          { amp: 0.2, freq: 24.0, phase: 0, noise_std: 0.01 }   // Higher harmonic
        ]
      },
      "Brain Wave (Alpha)": {
        components: [
          { amp: 1.0, freq: 0.1, phase: 0, noise_std: 0.1 },    // Alpha rhythm
          { amp: 0.3, freq: 0.2, phase: 0, noise_std: 0.05 },   // Beta component
          { amp: 0.1, freq: 0.05, phase: 0, noise_std: 0.02 }   // Theta component
        ]
      }
    };

    // Function to apply a predefined pattern to a signal
    function applyPattern(signalId, patternName) {
      const signal = signals.find(s => s.id === signalId);
      if (!signal) return;

      const pattern = naturalPatterns[patternName];
      if (!pattern) return;

      // Update signal name if a pattern is selected
      if (patternName) {
        signal.name = patternName;
        document.getElementById(`signal${signalId}_name`).value = patternName;
      }

      // Clear existing components
      signal.components = [];
      const compContainer = document.getElementById(`signal${signalId}_components`);
      compContainer.innerHTML = '';

      // Add new components from pattern
      pattern.components.forEach((patternComp, index) => {
        signal.componentCounter = (signal.componentCounter || 0) + 1;
        const compId = signal.componentCounter;
        const newComp = { id: compId };
        signal.components.push(newComp);

        const compHtml = `
        <div class="controls-row" id="signal${signalId}_comp${compId}_row">
          <span class="component-badge">Comp ${compId}</span>
          <div class="control-group">
            <input type="number" class="form-control" id="signal${signalId}_comp${compId}_amp" value="${patternComp.amp}" step="0.1" oninput="updatePlot()">
          </div>
          <div class="control-group">
            <input type="number" class="form-control" id="signal${signalId}_comp${compId}_freq" value="${patternComp.freq}" step="0.1" oninput="updatePlot()">
          </div>
          <div class="control-group">
            <input type="number" class="form-control" id="signal${signalId}_comp${compId}_phase" value="${patternComp.phase}" step="0.1" oninput="updatePlot()">
          </div>
          <div class="control-group">
            <input type="number" class="form-control" id="signal${signalId}_comp${compId}_noise" value="${patternComp.noise_std}" step="0.01" oninput="updatePlot()">
          </div>
          <button class="btn btn-danger btn-sm" onclick="removeSineComponent(${signalId}, ${compId})">
            <i class="fas fa-times"></i>
          </button>
        </div>
        `;
        compContainer.insertAdjacentHTML('beforeend', compHtml);
      });

      updatePlot();
    }

    // Modify the addSignal function to include editable name and muted color
    function addSignal() {
      signalCounter++;
      const signalId = signalCounter;
      // Assign a color from our presets
      const colorIndex = (signalId - 1) % 10; // Use only the first 10 colors (the muted ones)
      const colorName = getMutedColorName(colorIndex);
      const colorValue = colorPresets[colorName];
      
      const signal = { 
        id: signalId, 
        components: [], 
        name: `Signal ${signalId}`,
        color: colorValue
      };
      signals.push(signal);
      const signalHtml = `
      <div class="card" id="signal${signalId}_card">
        <div class="card-header">
          <input type="text" class="signal-name-input" id="signal${signalId}_name" value="Signal ${signalId}" onchange="updateSignalName(${signalId}, this.value)">
          <div class="d-flex gap-2">
            <select class="form-select form-select-sm" style="width: auto;" onchange="applyPattern(${signalId}, this.value)">
              <option value="">Custom</option>
              ${Object.keys(naturalPatterns).map(pattern => 
                `<option value="${pattern}">${pattern}</option>`
              ).join('')}
            </select>
            <button class="btn btn-danger btn-sm" onclick="removeSignal(${signalId})">
              <i class="fas fa-trash"></i> Remove
            </button>
          </div>
        </div>
        <div class="card-body">
          <div class="header-row">
            <div class="signal-info">
              <i class="fas fa-wave-square"></i> Components:
            </div>
            <div class="d-flex gap-2 align-items-center">
              <div class="color-selector" style="display: flex; align-items: center; gap: 4px;">
                <select class="form-select form-select-sm" id="signal${signalId}_colorSelect" 
                  style="width: auto;" onchange="handleColorSelection(${signalId}, this)">
                  ${Object.entries(colorPresets).map(([name, color]) => 
                    createColorOption(name, color)
                  ).join('')}
                  <option value="custom">Custom Color</option>
                </select>
                <div class="color-preview" style="width: 24px; height: 24px; border-radius: 4px; background-color: ${signal.color}; border: 1px solid #444;"></div>
                <input type="color" class="form-control form-control-color" 
                  id="signal${signalId}_color" value="${signal.color}" 
                  onchange="handleCustomColorChange(${signalId}, this)" 
                  style="width: 24px; height: 24px; padding: 0; display: ${getColorName(signal.color) === 'Custom' ? 'block' : 'none'};">
              </div>
              <button class="btn btn-secondary btn-sm" onclick="addSineComponent(${signalId})">
                <i class="fas fa-plus"></i> Add Component
              </button>
            </div>
          </div>
          <!-- Add controls header with labels -->
          <div class="controls-header">
            <div class="control-label">Amplitude</div>
            <div class="control-label">Frequency</div>
            <div class="control-label">Phase</div>
            <div class="control-label">Noise</div>
            <div style="width: 32px;"></div><!-- Space for delete button -->
          </div>
          <div id="signal${signalId}_components"></div>
        </div>
      </div>
      `;
      const signalsContainer = document.getElementById('signalsContainer');
      signalsContainer.insertAdjacentHTML('beforeend', signalHtml);
      
      // Set correct color value in dropdown
      setTimeout(() => {
        const dropdown = document.getElementById(`signal${signalId}_colorSelect`);
        if (dropdown) {
          dropdown.value = colorName;
        }
        styleColorDropdowns();
      }, 0);
      
      addSineComponent(signalId);
      updatePlot();
    }

    // Removes a signal entirely.
    function removeSignal(signalId) {
      signals = signals.filter(s => s.id !== signalId);
      const signalCard = document.getElementById(`signal${signalId}_card`);
      if (signalCard) {
        signalCard.remove();
      }
      updatePlot();
    }

    // Save the current signal configuration as a JSON file.
    function saveConfig() {
      const config = { signals: [] };
      signals.forEach(signal => {
        const components = [];
        signal.components.forEach(component => {
          const amp = parseFloat(document.getElementById(`signal${signal.id}_comp${component.id}_amp`).value) || 0;
          const freq = parseFloat(document.getElementById(`signal${signal.id}_comp${component.id}_freq`).value) || 0;
          const phase = parseFloat(document.getElementById(`signal${signal.id}_comp${component.id}_phase`).value) || 0;
          const noise = parseFloat(document.getElementById(`signal${signal.id}_comp${component.id}_noise`).value) || 0;
          components.push({ amp: amp, freq: freq, phase: phase, noise_std: noise });
        });
        config.signals.push({ components: components });
      });
      const jsonStr = JSON.stringify(config, null, 2);
      const blob = new Blob([jsonStr], { type: "application/json" });
      const url  = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'signal_config.json';
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }

    document.getElementById('addSignalBtn').addEventListener('click', addSignal);
    document.getElementById('saveConfigBtn').addEventListener('click', saveConfig);

    // Function to apply better styling to color dropdowns
    function styleColorDropdowns() {
      document.querySelectorAll('.color-selector select').forEach(select => {
        Array.from(select.options).forEach(option => {
          const color = option.dataset.color;
          if (color) {
            // Instead of coloring the whole option, add a colored swatch
            // First ensure we don't add multiple swatches
            if (!option.querySelector('.color-option-swatch')) {
              const originalText = option.textContent;
              option.innerHTML = `<span class="color-option-text">${originalText}<span class="color-option-swatch" style="background-color: ${color};"></span></span>`;
            }
          }
        });
      });
    }

    // Toggle pause/play
    function togglePausePlay() {
      if (animationSpeed === 0) {
        // Resume animation with previous speed or default to 1
        const prevSpeed = parseFloat(document.getElementById('speedIndicator').textContent) || 1;
        animationSpeed = prevSpeed;
        document.getElementById('speedIndicator').textContent = animationSpeed + 'x';
        document.getElementById('playIcon').style.display = 'none';
        document.getElementById('pauseIcon').style.display = 'inline';
        animate();
      } else {
        // Pause animation
        cancelAnimationFrame(animationFrameId);
        animationFrameId = null;
        animationSpeed = 0;
        document.getElementById('playIcon').style.display = 'inline';
        document.getElementById('pauseIcon').style.display = 'none';
      }
      // Update the speed in settings modal for consistency
      document.getElementById('animationSpeed').value = animationSpeed;
    }
    
    // Decrease animation speed
    function decreaseSpeed() {
      if (animationSpeed > 0) {
        animationSpeed = Math.max(0.1, animationSpeed - 0.1).toFixed(1);
        document.getElementById('speedIndicator').textContent = animationSpeed + 'x';
        // Update the speed in settings modal for consistency
        document.getElementById('animationSpeed').value = animationSpeed;
        
        // If speed becomes 0, update pause/play button
        if (parseFloat(animationSpeed) === 0) {
          cancelAnimationFrame(animationFrameId);
          animationFrameId = null;
          document.getElementById('playIcon').style.display = 'inline';
          document.getElementById('pauseIcon').style.display = 'none';
        }
      }
    }
    
    // Increase animation speed
    function increaseSpeed() {
      animationSpeed = (parseFloat(animationSpeed) + 0.1).toFixed(1);
      document.getElementById('speedIndicator').textContent = animationSpeed + 'x';
      // Update the speed in settings modal for consistency
      document.getElementById('animationSpeed').value = animationSpeed;
      
      // If animation was paused, restart it
      if (!animationFrameId) {
        document.getElementById('playIcon').style.display = 'none';
        document.getElementById('pauseIcon').style.display = 'inline';
        animate();
      }
    }
    
    // Initialize event listeners for floating controls
    function initFloatingControls() {
      document.getElementById('pausePlayBtn').addEventListener('click', togglePausePlay);
      document.getElementById('speedDownBtn').addEventListener('click', decreaseSpeed);
      document.getElementById('speedUpBtn').addEventListener('click', increaseSpeed);
      
      // Initialize speed indicator
      document.getElementById('speedIndicator').textContent = animationSpeed + 'x';
      // Set initial pause/play button state
      if (animationSpeed > 0) {
        document.getElementById('playIcon').style.display = 'none';
        document.getElementById('pauseIcon').style.display = 'inline';
      } else {
        document.getElementById('playIcon').style.display = 'inline';
        document.getElementById('pauseIcon').style.display = 'none';
      }
    }

    // Load initial configuration instead of adding a single signal
    loadInitialConfig();
    // Style the color dropdowns
    styleColorDropdowns();
    // Initialize floating controls
    initFloatingControls();
    // Start the animation loop
    requestAnimationFrame(animate);

    // Initialize settings modal values
    document.getElementById('settingsModal').addEventListener('show.bs.modal', function () {
      document.getElementById('yAxisMin').value = yAxisMin;
      document.getElementById('yAxisMax').value = yAxisMax;
      document.getElementById('animationSpeed').value = animationSpeed;
      document.getElementById('xAxisWidth').value = xAxisWidth;
      document.getElementById('rightMargin').value = rightPadding / xAxisWidth;
    });

    // Add event listener for resetting y-axis
    document.getElementById('resetYAxis').addEventListener('click', function() {
      isYAxisFixed = false;
      const [calculatedMin, calculatedMax] = calculateYRange();
      document.getElementById('yAxisMin').value = calculatedMin.toFixed(1);
      document.getElementById('yAxisMax').value = calculatedMax.toFixed(1);
      yAxisMin = calculatedMin;
      yAxisMax = calculatedMax;
      updatePlot();
    });

    // Add function to update signal name
    function updateSignalName(signalId, newName) {
      const signal = signals.find(s => s.id === signalId);
      if (signal) {
        signal.name = newName;
        updatePlot();
      }
    }

    // Get a muted color for each signal based on index - matching getMutedColorName
    function getMutedColor(index) {
      const mutedColors = [
        'rgba(0, 229, 255, 0.5)',     // muted blue
        'rgba(57, 255, 20, 0.5)',     // muted green
        'rgba(255, 23, 68, 0.5)',     // muted red
        'rgba(255, 255, 0, 0.5)',     // muted yellow
        'rgba(0, 255, 127, 0.5)',     // muted teal
        'rgba(170, 255, 0, 0.5)',     // muted lime
        'rgba(0, 140, 255, 0.5)',     // muted sky blue
        'rgba(191, 0, 255, 0.5)',     // muted purple
        'rgba(255, 145, 0, 0.5)',     // muted orange
        'rgba(255, 0, 255, 0.5)'      // muted pink
      ];
      return mutedColors[index % mutedColors.length];
    }

    // Get a muted color name for each signal based on index
    function getMutedColorName(index) {
      const mutedColorNames = [
        'Muted Blue',
        'Muted Green',
        'Muted Red',
        'Muted Yellow',
        'Muted Teal',
        'Muted Lime',
        'Muted Sky Blue',
        'Muted Purple',
        'Muted Orange',
        'Muted Pink'
      ];
      return mutedColorNames[index % mutedColorNames.length];
    }
  </script>
  
  <!-- Bootstrap 5 JS Bundle -->
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
</body>
</html>
